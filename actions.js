  const { prisma } = require("./db");
  const { SubscriptionType } = require("@prisma/client");
  const { createInvoice, applyCreditIfNeeded } = require("./payment");
  const path = require("path");
  const { Markup } = require("telegraf");
  const fs = require("fs");


  const {
    PLANS,
    TOPUP_AMOUNTS,
    ruMoney,
    formatDate,
    calcEndDate,
    mainMenu,
    buyMenu,
    topupMenu,
    getDisplayLabel, // üëà –¥–æ–±–∞–≤–ª—è–µ–º
    infoMenu,
    instructionsMenu,
  } = require("./menus");
  const MARZBAN_API_URL = process.env.MARZBAN_API_URL;


  /* –£—Ç–∏–ª–∏—Ç–∞: –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è */
  async function editOrAnswer(ctx, text, keyboard) {
    try {
      const currentText = ctx.callbackQuery?.message?.text;
      const currentKb = JSON.stringify(
        ctx.callbackQuery?.message?.reply_markup?.inline_keyboard || []
      );
      const nextKb = JSON.stringify(keyboard?.reply_markup?.inline_keyboard || []);

      if (currentText === text && currentKb === nextKb) {
        await ctx.answerCbQuery("–ê–∫—Ç—É–∞–ª—å–Ω–æ");
        return;
      }
      await ctx.editMessageText(text, keyboard);
    } catch (err) {
      const desc = err?.response?.description || err?.message || "";
      if (desc.includes("message is not modified")) {
        await ctx.answerCbQuery("–ê–∫—Ç—É–∞–ª—å–Ω–æ");
        return;
      }
      if (desc.includes("message can't be edited")) {
        await ctx.reply(text, keyboard);
        return;
      }
      console.error("editOrAnswer error:", desc);
    }
  }

  /* –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤—Å–µ –¥–µ–π—Å—Ç–≤–∏—è */
  function registerActions(bot) {
    // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è ‚Äî –±–∞–ª–∞–Ω—Å –∏ –ø–æ–¥–ø–∏—Å–∫–∏
bot.action("instructions", async (ctx) => {
  await ctx.answerCbQuery();
  await editOrAnswer(ctx, "üìñ –í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É:", instructionsMenu());
});

// –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤ —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π
function getText(fileName) {
  const filePath = path.join(__dirname, "texts", fileName);
  return fs.readFileSync(filePath, "utf-8");
}

// iOS / macOS
bot.action("guide_ios", async (ctx) => {
  await ctx.answerCbQuery();
  const text = getText("ios-macos.txt");
  await editOrAnswer(ctx, text, instructionsMenu());
});

// Android
bot.action("guide_android", async (ctx) => {
  await ctx.answerCbQuery();
  const text = getText("android.txt");
  await editOrAnswer(ctx, text, instructionsMenu());
});

// Windows
bot.action("guide_windows", async (ctx) => {
  await ctx.answerCbQuery();
  const text = getText("windows.txt");
  await editOrAnswer(ctx, text, instructionsMenu());
});
    // –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É ‚Äî –≤—ã–≤–æ–¥ –ø–ª–∞–Ω–æ–≤
    bot.action("buy", async (ctx) => {
      await ctx.answerCbQuery();
      await editOrAnswer(ctx, "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É:", buyMenu());
    });

    // –ü–æ–∫—É–ø–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞
  const fetch = require("node-fetch"); // –Ω—É–∂–µ–Ω npm i node-fetch@2

  // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è ‚Äî —Ç–µ–ø–µ—Ä—å –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø–æ–¥–º–µ–Ω—é
bot.action("info", async (ctx) => {
  await ctx.answerCbQuery();
  await editOrAnswer(ctx, "‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:", infoMenu(ctx.dbUser.balance));
});


// –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ
bot.action("tos", async (ctx) => {
  await ctx.answerCbQuery();
  const text = fs.readFileSync("texts/tos.txt", "utf8");
  await editOrAnswer(ctx, text, infoMenu(ctx.dbUser.balance));
});

// –ü–æ–ª–∏—Ç–∏–∫–∞ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏
bot.action("privacy", async (ctx) => {
  await ctx.answerCbQuery();
  const text = fs.readFileSync("texts/privacy.txt", "utf8");
  await editOrAnswer(ctx, text, infoMenu(ctx.dbUser.balance));
});

  // –≤–Ω—É—Ç—Ä–∏ registerActions(bot)
  bot.action(/^buy_(M1|M3|M6|M12)$/, async (ctx) => {
    await ctx.answerCbQuery();
    const planKey = ctx.match[1];
    const plan = PLANS[planKey];

    try {
      const result = await prisma.$transaction(async (tx) => {
        // 1) —Å–ø–∏—Å–∞–Ω–∏–µ –¥–µ–Ω–µ–≥
        const dec = await tx.user.updateMany({
          where: { id: ctx.dbUser.id, balance: { gte: plan.price } },
          data: { balance: { decrement: plan.price } },
        });
        if (dec.count === 0) {
          return { ok: false, reason: "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤" };
        }

        // 2) —Å–æ–∑–¥–∞—ë–º –ø–æ–¥–ø–∏—Å–∫—É (–ø–æ–∫–∞ –±–µ–∑ —Å—Å—ã–ª–∫–∏)
        const sub = await tx.subscription.create({
          data: {
            userId: ctx.dbUser.id,
            type: SubscriptionType[plan.type],
            startDate: new Date(),
            endDate: calcEndDate(plan.months),
          },
        });

        // 3) —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å
        const user = await tx.user.findUnique({ where: { id: ctx.dbUser.id } });
        return { ok: true, sub, balance: user.balance };
      });

      if (!result.ok) {
        await editOrAnswer(
          ctx,
          `‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏: ${plan.label} –∑–∞ ${ruMoney(plan.price)}.\n–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –≤ –º–µ–Ω—é ¬´–ë–∞–ª–∞–Ω—Å¬ª.`,
          buyMenu()
        );
        return;
      }

      // üî• –í–´–ó–û–í MARZBAN API
      const expireSeconds = plan.months === 12 ? 365*24*60*60 : plan.months*30*24*60*60;
      const expire = Math.floor(Date.now() / 1000) + expireSeconds;

      const username = `${ctx.dbUser.telegramId}_${plan.type}_${result.sub.id}`;

      const apiResponse = await fetch(`${MARZBAN_API_URL}/users`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
          username, // üî• —Ç–µ–ø–µ—Ä—å –∏–º—è = telegramId_—Å—Ä–æ–∫_id–ü–æ–¥–ø–∏—Å–∫–∏
          status: "active",
          expire,
          proxies: { vless: {} },
          note: `Telegram user ${ctx.dbUser.accountName || ctx.dbUser.telegramId}`,
      }),
      });


      if (!apiResponse.ok) {
        console.error("Marzban API error", await apiResponse.text());
      } else {
        const apiUser = await apiResponse.json();

        // –¥–æ–ø—É—Å—Ç–∏–º, –≤ –æ—Ç–≤–µ—Ç–µ Marzban –µ—Å—Ç—å subscription_url
        const subscriptionUrl = apiUser?.subscription_url || null;

        // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        await prisma.subscription.update({
          where: { id: result.sub.id },
          data: { subscriptionUrl },
        });
      }

let successText = `‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞: ${plan.label}
–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: ${formatDate(result.sub.endDate)}

–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: ${ruMoney(result.balance)}

‚ÑπÔ∏è –ß—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –≤–∞—à–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª ¬´–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏¬ª.`;

// –µ—Å–ª–∏ –≤ –æ—Ç–≤–µ—Ç–µ –æ—Ç API –ø—Ä–∏—à–ª–∞ —Å—Å—ã–ª–∫–∞ –∏ –º—ã –µ—ë —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏
const lastSub = await prisma.subscription.findUnique({ where: { id: result.sub.id } });
if (lastSub.subscriptionUrl) {
  successText += `\n\nüîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞: ${lastSub.subscriptionUrl}`;
}

// –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏" –≤ –º–µ–Ω—é
const keyboard = Markup.inlineKeyboard([
  [Markup.button.callback("üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏", "instructions")],
  [Markup.button.callback("‚¨ÖÔ∏è –í –º–µ–Ω—é", "back")]
]);

await editOrAnswer(ctx, successText, keyboard);


    } catch (e) {
      console.error("buy error:", e);
      await editOrAnswer(ctx, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", buyMenu());
    }
  });


    // –ë–∞–ª–∞–Ω—Å ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –∏ –ø–æ–ø–æ–ª–Ω–∏—Ç—å
    bot.action("balance", async (ctx) => {
      await ctx.answerCbQuery();
      const user = await prisma.user.findUnique({ where: { id: ctx.dbUser.id } });
      const text = `üíº –ë–∞–ª–∞–Ω—Å: ${ruMoney(user.balance)}\n–í—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:`;
      await editOrAnswer(ctx, text, topupMenu());
    });

  const { createInvoice } = require("./payment");

  // ‚úÖ Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è callback_data
  bot.use(async (ctx, next) => {
    if (ctx.callbackQuery) {
      console.log(`[CALLBACK] from user=${ctx.dbUser?.id}, data="${ctx.callbackQuery.data}"`);
    }
    return next();
  });

  bot.action(/^topup_(\d+)$/, async (ctx) => {
    await ctx.answerCbQuery();
    const amount = parseInt(ctx.match[1], 10);
    if (isNaN(amount) || amount <= 0) {
      console.warn(`[TOPUP] Invalid amount: "${ctx.match[1]}"`);
      return ctx.reply("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è.", topupMenu());
    }

    console.log(`[TOPUP] User ${ctx.dbUser.id} requested topup for ${amount} ‚ÇΩ`);
    try {
      const { link, topup } = await createInvoice(ctx.dbUser.id, amount);
      console.log(`[TOPUP] Created invoice: id=${topup.id}, orderId=${topup.orderId}, amount=${topup.amount}`);

      await ctx.reply(
        `üí≥ –î–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–∞ ${ruMoney(amount)} –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:\n${link}\n\n–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤–µ—Ä–Ω–∏—Ç–µ—Å—å —Å—é–¥–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É".`,
        Markup.inlineKeyboard([
          [Markup.button.callback("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É", `check_topup_${topup.id}`)],
          [Markup.button.callback("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "back")],
        ])
      );
    } catch (e) {
      console.error("[TOPUP] Error creating invoice:", e);
      await ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á—ë—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", topupMenu());
    }
  });

  bot.action(/^check_topup_(\d+)$/, async (ctx) => {
    await ctx.answerCbQuery();
    const id = parseInt(ctx.match[1], 10);
    if (isNaN(id)) {
      console.warn(`[CHECK] Invalid topup id: "${ctx.match[1]}"`);
      return ctx.reply("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–ª–∞—Ç—ã.");
    }

    console.log(`[CHECK] User ${ctx.dbUser.id} is checking topup id=${id}`);

    try {
      const topup = await prisma.topUp.findUnique({ where: { id } });
      if (!topup || topup.userId !== ctx.dbUser.id) {
        console.warn(`[CHECK] Topup not found or another user. id=${id}, userId=${ctx.dbUser.id}`);
        return ctx.reply("–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.");
      }

      console.log(`[CHECK] Found topup: id=${topup.id}, amount=${topup.amount}, status=${topup.status}, orderId=${topup.orderId}, credited=${topup.credited}`);

      if (topup.status === "SUCCESS") {
        // ‚úÖ –ü—ã—Ç–∞–µ–º—Å—è –∑–∞—á–∏—Å–ª–∏—Ç—å (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ)
        const creditRes = await applyCreditIfNeeded(topup.id);
        console.log("[CHECK] applyCreditIfNeeded:", creditRes);

        const user = await prisma.user.findUnique({ where: { id: ctx.dbUser.id } });
        return ctx.reply(`‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\n–ë–∞–ª–∞–Ω—Å: ${ruMoney(user.balance)}`);
      } else if (topup.status === "FAILED" || topup.status === "TIMEOUT") {
        return ctx.reply("‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞.");
      } else if (topup.status === "PENDING") {
        return ctx.reply("‚è≥ –û–ø–ª–∞—Ç–∞ –µ—â—ë –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
      } else {
        console.error(`[CHECK] Unknown status "${topup.status}" for topup id=${id}`);
        return ctx.reply("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.");
      }
    } catch (err) {
      console.error(`[CHECK] Error while checking topup id=${id}:`, err);
      return ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –æ–ø–ª–∞—Ç—ã.");
    }
  });



    // –ú–æ–∏ –ø–æ–¥–ø–∏—Å–∫–∏ ‚Äî —Å–ø–∏—Å–æ–∫
    bot.action("my_subs", async (ctx) => {
      await ctx.answerCbQuery();

      const subs = await prisma.subscription.findMany({
        where: { userId: ctx.dbUser.id },
        orderBy: [
          { startDate: "desc" },
          { id: "desc" }
        ],
      });

      if (subs.length === 0) {
        await editOrAnswer(ctx, "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫.", mainMenu());
        return;
      }

  const buttons = subs.map((s) => {
    const label = getDisplayLabel(s);
    const suffix = s.endDate ? `–¥–æ ${formatDate(s.endDate)}` : "‚àû";
    return [Markup.button.callback(`${label} ${suffix}`, `sub_${s.id}`)];
  });


      buttons.push([Markup.button.callback("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "back")]);

      await editOrAnswer(
        ctx,
        "üì¶ –í–∞—à–∏ –ø–æ–¥–ø–∏—Å–∫–∏:",
        Markup.inlineKeyboard(buttons)
      );
    });

    // –ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –ø–æ–¥–ø–∏—Å–∫–∏
    bot.action(/sub_(\d+)/, async (ctx) => {
      await ctx.answerCbQuery();
      const id = parseInt(ctx.match[1], 10);
      const s = await prisma.subscription.findUnique({ where: { id } });

      if (!s || s.userId !== ctx.dbUser.id) {
        await editOrAnswer(ctx, "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", mainMenu());
        return;
      }

  const label = getDisplayLabel(s);
  let text = `üì¶ –ü–æ–¥–ø–∏—Å–∫–∞: ${label}
  –ù–∞—á–∞–ª–æ: ${formatDate(s.startDate)}
  –û–∫–æ–Ω—á–∞–Ω–∏–µ: ${formatDate(s.endDate)}`;


      if (s.subscriptionUrl) {
        text += `\n\nüîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞: ${s.subscriptionUrl}`;
      }

      const buttons = [[Markup.button.callback("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "my_subs")]];

      // –¢–æ–ª—å–∫–æ –¥–ª—è –ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ (M1, M3, M6, M12) –¥–æ–±–∞–≤–∏–º –∫–Ω–æ–ø–∫—É –ø—Ä–æ–¥–ª–µ–Ω–∏—è
      if (s.type !== "FREE") {
        buttons.unshift([Markup.button.callback("üîÑ –ü—Ä–æ–¥–ª–∏—Ç—å", `extend_choose_${s.id}`)]);
      }

      await editOrAnswer(ctx, text, Markup.inlineKeyboard(buttons));
    });

  // –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Å—Ä–æ–∫–∞ –ø—Ä–æ–¥–ª–µ–Ω–∏—è
  bot.action(/extend_choose_(\d+)/, async (ctx) => {
    await ctx.answerCbQuery();
    const id = parseInt(ctx.match[1], 10);
    const sub = await prisma.subscription.findUnique({ where: { id } });

    if (!sub || sub.userId !== ctx.dbUser.id) {
      await editOrAnswer(ctx, "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", mainMenu());
      return;
    }

    const buttons = Object.values(PLANS).map((plan) => {
      return [Markup.button.callback(`${plan.label} ‚Äî ${ruMoney(plan.price)}`, `extend_${id}_${plan.type}`)];
    });

    buttons.push([Markup.button.callback("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", `sub_${id}`)]);

    await editOrAnswer(ctx, "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –ø—Ä–æ–¥–ª–µ–Ω–∏—è:", Markup.inlineKeyboard(buttons));
  });

  // –ü—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å—Ä–æ–∫
  bot.action(/extend_(\d+)_(M1|M3|M6|M12)$/, async (ctx) => {
    await ctx.answerCbQuery();
    const id = parseInt(ctx.match[1], 10);
    const planKey = ctx.match[2];
    const plan = PLANS[planKey];

    const sub = await prisma.subscription.findUnique({ where: { id } });
    if (!sub || sub.userId !== ctx.dbUser.id) {
      await editOrAnswer(ctx, "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", mainMenu());
      return;
    }

    const user = await prisma.user.findUnique({ where: { id: ctx.dbUser.id } });
    if (user.balance < plan.price) {
      await editOrAnswer(
        ctx,
        `‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø—Ä–æ–¥–ª–µ–Ω–∏—è (${plan.label} –∑–∞ ${ruMoney(plan.price)}).\n–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å.`,
        mainMenu(user.balance)
      );
      return;
    }

    try {
      // —Å–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–Ω—å–≥–∏ –∏ –¥–≤–∏–≥–∞–µ–º –¥–∞—Ç—É –æ–∫–æ–Ω—á–∞–Ω–∏—è
      const newEndDate = sub.endDate ? new Date(sub.endDate) : new Date();
      newEndDate.setMonth(newEndDate.getMonth() + plan.months);

      const updated = await prisma.$transaction(async (tx) => {
        await tx.user.update({
          where: { id: ctx.dbUser.id },
          data: { balance: { decrement: plan.price } },
        });
        return tx.subscription.update({
          where: { id },
          data: { endDate: newEndDate },
        });
      });

      // üî• –≤—ã–∑–æ–≤ Marzban API extend
      try {
        const username = `${ctx.dbUser.telegramId}_${sub.type}_${sub.id}`;
        const days = plan.months * 30;

        const apiResponse = await fetch(
          `${MARZBAN_API_URL}/users/${username}/extend?days=${days}`,
          { method: "POST" }
        );

        if (!apiResponse.ok) {
          console.error("Marzban extend error:", await apiResponse.text());
        }
      } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ extend:", err);
      }

      const newBalance = user.balance - plan.price;

      await editOrAnswer(
        ctx,
        `‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø—Ä–æ–¥–ª–µ–Ω–∞ –Ω–∞ ${plan.label}
  –ù–æ–≤–∞—è –¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: ${formatDate(updated.endDate)}

  –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: ${ruMoney(newBalance)}`,
        mainMenu(newBalance)
      );
    } catch (err) {
      console.error("extend error:", err);
      await editOrAnswer(ctx, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", mainMenu(user.balance));
    }
  });

    // –ù–∞–∑–∞–¥ ‚Äî –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    bot.action("back", async (ctx) => {
      await ctx.answerCbQuery();
      const user = await prisma.user.findUnique({ where: { id: ctx.dbUser.id } });
      await editOrAnswer(ctx, "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", mainMenu(user.balance));
    });
  }

  module.exports = { registerActions };
